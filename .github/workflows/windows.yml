name: Windows

on:
  workflow_call:
    inputs:
      username:
        description: 'Custom Username'
        required: true
        type: string
      tunnel_provider:
        description: 'Select Tunnel Provider'
        required: true
        type: string
      region:
        description: 'Select Ngrok Tunnel Region'
        required: false
        type: string
        default: 'us'
      timeout:
        description: 'Session Timeout (minutes, max 360)'
        required: true
        type: string
      install_virtual_sound_card:
        description: 'Install Virtual Sound Card'
        required: false
        type: string
        default: 'false'
      set_default_browser:
        description: 'Set Default Browser to Chrome/BrowserOS'
        required: false
        type: string
        default: 'chrome'
      enable_google_drive_persistence:
        description: 'Enable Google Drive Persistence'
        required: false
        type: string
        default: 'true'
    secrets:
      NGROK_AUTH_TOKEN:
        required: true
      USER_PASSWORD:
        required: true
      GOOGLE_DRIVE_API_KEY:
        required: false
      GOOGLE_SERVICE_ACCOUNT_JSON:
        required: false
      GOOGLE_SHARED_DRIVE_ID:
        required: false

jobs:
  rdp-session:
    runs-on: windows-latest
    timeout-minutes: ${{ fromJSON(inputs.timeout) }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download previous backup artifact
        if: inputs.enable_google_drive_persistence == 'true'
        uses: actions/download-artifact@v4
        with:
          name: rdp-session-backup-${{ inputs.username }}-latest
          path: ./backups
        continue-on-error: true

      - name: Run pre-install script
        env:
          USER_PASSWORD: ${{ secrets.USER_PASSWORD }}
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
          GOOGLE_DRIVE_API_KEY: ${{ secrets.GOOGLE_DRIVE_API_KEY }}
        run: |
          ./scripts/preinstall-windows.ps1 -Username "${{ inputs.username }}" `
            -InstallVirtualSoundCard ${{ inputs.install_virtual_sound_card }} `
            -SetDefaultBrowser "${{ inputs.set_default_browser }}"
        shell: pwsh

      - name: Test Google Drive authentication
        if: inputs.enable_google_drive_persistence == 'true'
        env:
          GOOGLE_DRIVE_API_KEY: ${{ secrets.GOOGLE_DRIVE_API_KEY }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_SHARED_DRIVE_ID: ${{ secrets.GOOGLE_SHARED_DRIVE_ID }}
        run: |
          Write-Host "Testing Google Drive authentication..."
          if (-not $env:GOOGLE_DRIVE_API_KEY -and -not $env:GOOGLE_SERVICE_ACCOUNT_JSON) {
            Write-Warning "No Google Drive authentication configured. Skipping Google Drive integration."
          } else {
            ./scripts/test-google-auth.ps1
          }
        shell: pwsh

      - name: Restore user data from Google Drive
        if: inputs.enable_google_drive_persistence == 'true'
        env:
          GOOGLE_DRIVE_API_KEY: ${{ secrets.GOOGLE_DRIVE_API_KEY }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_SHARED_DRIVE_ID: ${{ secrets.GOOGLE_SHARED_DRIVE_ID }}
        run: |
          Write-Host "Restoring user data from Google Drive..."
          if (-not $env:GOOGLE_DRIVE_API_KEY -and -not $env:GOOGLE_SERVICE_ACCOUNT_JSON) {
            Write-Warning "No Google Drive authentication configured. Skipping restore."
          } else {
            ./scripts/google-drive-sync.ps1 -Action "restore" -Username "${{ inputs.username }}"
          }
        shell: pwsh

      - name: Create Google Drive sync shortcuts
        if: inputs.enable_google_drive_persistence == 'true'
        env:
          GOOGLE_DRIVE_API_KEY: ${{ secrets.GOOGLE_DRIVE_API_KEY }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_SHARED_DRIVE_ID: ${{ secrets.GOOGLE_SHARED_DRIVE_ID }}
        run: |
          Write-Host "Creating desktop shortcuts for Google Drive sync..."
          if (-not $env:GOOGLE_DRIVE_API_KEY -and -not $env:GOOGLE_SERVICE_ACCOUNT_JSON) {
            Write-Warning "No Google Drive authentication configured. Skipping shortcut creation."
          } else {
            ./scripts/create-sync-shortcuts.ps1 -Username "${{ inputs.username }}"
          }
        shell: pwsh

      - name: Enable RDP
        shell: pwsh
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          netsh advfirewall firewall add rule name="RDP" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force

      - name: Install jq
        run: |
          mkdir -p /usr/local/bin
          curl -L -o /usr/local/bin/jq.exe https://github.com/stedolan/jq/releases/download/jq-1.6/jq-win64.exe
          chmod +x /usr/local/bin/jq.exe
        shell: bash

      - name: Setup Ngrok Tunnel
        if: inputs.tunnel_provider == 'ngrok'
        shell: bash
        run: |
          AUTH_TOKEN="${{ secrets.NGROK_AUTH_TOKEN }}"
          NGROK_LOG="ngrok.log"
          CONFIG_FILE="ngrok.yml"
          PORT="3389"

          echo "version: \"2\"" > $CONFIG_FILE
          echo "authtoken: $AUTH_TOKEN" >> $CONFIG_FILE

          echo "Installing ngrok..."
          curl -sL https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -o ngrok.zip
          unzip -o ngrok.zip

          echo "Starting ngrok tunnel on port $PORT..."
          pwsh -Command "Start-Process -NoNewWindow -FilePath 'ngrok.exe' -ArgumentList 'tcp $PORT --config $CONFIG_FILE --log $NGROK_LOG --region=${{ inputs.region }}'"

          echo "Waiting for ngrok to start..."
          sleep 15

          for i in {1..5}; do
            TUNNEL_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url // empty')
            if [ -n "$TUNNEL_URL" ]; then
              break
            fi
            echo "Attempt $i: Tunnel not ready yet, waiting..."
            sleep 5
          done

          if [ -z "$TUNNEL_URL" ]; then
            echo "::error::Failed to get ngrok tunnel info after multiple attempts."
            echo "Ngrok log content:"
            cat "$NGROK_LOG" 2>/dev/null || echo "No ngrok log found"
            exit 1
          fi

          RDP_ADDRESS=$(echo "$TUNNEL_URL" | sed 's|tcp://||' | cut -d: -f1)
          RDP_PORT=$(echo "$TUNNEL_URL" | sed 's|tcp://||' | cut -d: -f2)
          echo "RDP_ADDRESS=$RDP_ADDRESS" >> $GITHUB_ENV
          echo "RDP_PORT=$RDP_PORT" >> $GITHUB_ENV
          echo "Tunnel established successfully: $TUNNEL_URL"

      - name: Setup Cloudflare Tunnel
        if: inputs.tunnel_provider == 'cloudflare'
        shell: bash
        run: |
          echo "Installing cloudflared..."
          curl -L --output cloudflared.exe https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe

          echo "Starting cloudflare tunnel..."
          CF_LOG="cloudflared.log"

          ./cloudflared.exe tunnel --url rdp://localhost:3389 > $CF_LOG 2>&1 &

          echo "Waiting for cloudflared to start..."
          sleep 15

          for i in {1..10}; do
            TUNNEL_URL=$(grep -o 'https://[a-z-]*\.trycloudflare\.com' $CF_LOG | head -n 1 || true)
            if [ -n "$TUNNEL_URL" ]; then
              break
            fi
            echo "Attempt $i: Tunnel not ready yet, waiting..."
            sleep 3
          done

          if [ -z "$TUNNEL_URL" ]; then
            echo "::error::Failed to get Cloudflare tunnel info after multiple attempts."
            echo "Cloudflared log content:"
            cat "$CF_LOG" 2>/dev/null || echo "No cloudflared log found"
            exit 1
          fi

          RDP_ADDRESS=$(echo "$TUNNEL_URL" | sed 's|https://||')
          echo "RDP_ADDRESS=$RDP_ADDRESS" >> $GITHUB_ENV
          echo "Tunnel established successfully: $RDP_ADDRESS"

      - name: Display Connection Details (Ngrok)
        if: inputs.tunnel_provider == 'ngrok'
        run: |
          echo "ðŸŽ¯ CONNECTION DETAILS ðŸŽ¯"
          echo "=========================================="
          echo "OS: windows-latest"
          echo "Protocol: RDP (Use Remote Desktop Connection)"
          echo "Port: 3389"
          echo "Address: ${{ env.RDP_ADDRESS }}"
          echo "Port: ${{ env.RDP_PORT }}"
          echo "Username: ${{ inputs.username }}"
          echo "Password: ${{ secrets.USER_PASSWORD }}"
          echo "=========================================="
          echo "Connection string: ${{ env.RDP_ADDRESS }}:${{ env.RDP_PORT }}"
        shell: bash

      - name: Display Connection Details (Cloudflare)
        if: inputs.tunnel_provider == 'cloudflare'
        run: |
          echo "ðŸŽ¯ CLOUDFLARE CONNECTION DETAILS ðŸŽ¯"
          echo "=========================================="
          echo "OS: windows-latest"
          echo "Protocol: RDP (Use Remote Desktop Connection)"
          echo "Address: ${{ env.RDP_ADDRESS }}"
          echo "Username: ${{ inputs.username }}"
          echo "Password: ${{ secrets.USER_PASSWORD }}"
          echo "=========================================="
        shell: bash

      - name: Keep Workflow Alive
        shell: bash
        run: |
          echo "Remote desktop session is now active!"
          echo "The workflow will remain running for ${{ inputs.timeout }} minutes."
          echo "Press Ctrl+C in the workflow logs to terminate the session early."
          
          TIMEOUT_MINUTES=${{ inputs.timeout }}
          TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
          PRE_TIMEOUT_BACKUP_SECONDS=$((TIMEOUT_SECONDS - 300))  # 5 minutes before timeout
          
          # Create a background job to backup data every 30 minutes (if Google Drive persistence is enabled)
          if [ '${{ inputs.enable_google_drive_persistence }}' = 'true' ]; then
            pwsh -Command "
            \$timeoutMinutes = $TIMEOUT_MINUTES
            \$preTimeoutSeconds = $PRE_TIMEOUT_BACKUP_SECONDS
            
            # Periodic backup job (every 30 minutes)
            \$periodicJob = Start-Job -ScriptBlock {
              param(\$username)
              while (\$true) {
                Start-Sleep -Seconds 1800  # 30 minutes
                try {
                  Write-Host 'â° Creating periodic backup...'
                  & './scripts/google-drive-sync.ps1' -Action 'backup' -Username \$username
                  Write-Host 'âœ… Periodic backup completed'
                } catch {
                  Write-Warning 'âŒ Periodic backup failed: \$_'
                }
              }
            } -ArgumentList '${{ inputs.username }}'
            
            # Pre-timeout backup job (5 minutes before session ends)
            \$preTimeoutJob = Start-Job -ScriptBlock {
              param(\$username, \$preTimeoutSeconds)
              Start-Sleep -Seconds \$preTimeoutSeconds
              try {
                Write-Host 'âš ï¸ SESSION ENDING SOON! Running enhanced pre-timeout backup...'
                & './scripts/pre-timeout-backup.ps1' -Username \$username -MinutesBeforeTimeout 5
              } catch {
                Write-Warning 'âŒ Pre-timeout backup script failed: \$_'
                # Fallback to direct backup
                try {
                  Write-Host 'ðŸ”„ Attempting fallback backup...'
                  & './scripts/google-drive-sync.ps1' -Action 'backup' -Username \$username
                  Write-Host 'âœ… Fallback backup completed'
                } catch {
                  Write-Warning 'âŒ Fallback backup also failed: \$_'
                }
              }
            } -ArgumentList '${{ inputs.username }}', \$preTimeoutSeconds
            
            # Timeout handler job (runs throughout the session)
            \$timeoutHandlerJob = Start-Job -ScriptBlock {
              param(\$username)
              & './scripts/timeout-handler.ps1' -Username \$username
            } -ArgumentList '${{ inputs.username }}'
            
            Write-Host 'ðŸ”„ Started periodic backup job with ID:' \$periodicJob.Id
            Write-Host 'â° Started pre-timeout backup job with ID:' \$preTimeoutJob.Id
            Write-Host 'ðŸ›¡ï¸ Started timeout handler job with ID:' \$timeoutHandlerJob.Id
            Write-Host 'ðŸ“‹ Backup schedule:'
            Write-Host '   â€¢ Every 30 minutes during session'
            Write-Host '   â€¢ 5 minutes before timeout (' (Get-Date).AddSeconds(\$preTimeoutSeconds).ToString('HH:mm:ss') ')'
            Write-Host '   â€¢ At session end (final backup)'
            Write-Host '   â€¢ Emergency backup on unexpected termination'
            "
          else
            echo "Google Drive persistence is disabled. Skipping periodic backups."
          fi
          
          echo ""
          echo "ðŸ• Session started at: $(date)"
          echo "â° Session will end at: $(date -d "+${TIMEOUT_MINUTES} minutes")"
          echo "âš ï¸  Pre-timeout backup at: $(date -d "+$((TIMEOUT_MINUTES - 5)) minutes")"
          echo ""
          
          sleep ${TIMEOUT_MINUTES}m

      - name: Final backup before shutdown
        if: always() && inputs.enable_google_drive_persistence == 'true'
        env:
          GOOGLE_DRIVE_API_KEY: ${{ secrets.GOOGLE_DRIVE_API_KEY }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_SHARED_DRIVE_ID: ${{ secrets.GOOGLE_SHARED_DRIVE_ID }}
        run: |
          Write-Host "Creating final backup before shutdown..."
          try {
            ./scripts/google-drive-sync.ps1 -Action "backup" -Username "${{ inputs.username }}"
            Write-Host "Final backup completed successfully"
          } catch {
            Write-Warning "Final backup failed: $_"
          }
        shell: pwsh

      - name: Upload backup as artifact (with run number)
        if: always() && inputs.enable_google_drive_persistence == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: rdp-session-backup-${{ inputs.username }}-${{ github.run_number }}
          path: ./backups/rdp-session-${{ inputs.username }}.zip
          retention-days: 30
          if-no-files-found: warn

      - name: Upload backup as latest artifact (for next session)
        if: always() && inputs.enable_google_drive_persistence == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: rdp-session-backup-${{ inputs.username }}-latest
          path: ./backups/rdp-session-${{ inputs.username }}.zip
          retention-days: 7
          if-no-files-found: warn
          overwrite: true

      - name: Clean up cloudflared process
        if: always() && inputs.tunnel_provider == 'cloudflare'
        shell: bash
        run: |
          echo "Cleaning up cloudflared process..."
          taskkill /IM cloudflared.exe /F 2>nul || echo "cloudflared process not found"
